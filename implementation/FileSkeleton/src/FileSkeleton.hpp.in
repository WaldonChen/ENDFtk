#ifndef ENDFTK_IMPLEMENTATION_FILESKELETON_SRC_FILESKELETON_HPP
#define ENDFTK_IMPLEMENTATION_FILESKELETON_SRC_FILESKELETON_HPP

#include "ENDFtk.hpp"

namespace ENDFtk {
namespace implementation {

template<typename Iterator>
FileSkeleton<Iterator>::FileSkeleton(
  const HeadRecord& mHead, 
  Iterator begin, Iterator& position, const Iterator& end, long& lineNumber )
  : begin_(begin)
{
  try{
    sectionsIndexed_.emplace_back(mHead, begin, position, end, lineNumber);
    auto& skeletor = sectionsIndexed_.back();
    sections_.emplace(skeletor.MT(), skeletor);

    this->MF_  = mHead.MF();

    auto FEND = StructureDivision(position, end, lineNumber); 

    while( not FEND.isFend() ){
      LOG(INFO) << "diff before: " << end-position;
      if(position >= end){
        LOG(ERROR) << "File encountered end of stream before reading FEND";
        throw std::exception();
      }
      sectionsIndexed_.emplace_back(asHead(FEND), 
                                    begin, position, end, lineNumber);
      skeletor = sectionsIndexed_.back();
      sections_.emplace(skeletor.MT(), skeletor);

      begin = position;
      FEND = StructureDivision(position, end, lineNumber); 
      LOG(INFO) << "diff after: " << end-position;
      LOG(INFO) << "isFEND? " << FEND.isFend();
    }
  } catch( std::exception& e ){
    LOG(INFO) << "Trouble when creating a FileSkeleton";
    LOG(INFO) << "Line number=" << lineNumber << ", MF=" << this->MF_;
    throw e;
  }

  LOG(INFO) << "Trying to set end_.";
  end_ = position;
  LOG(INFO) << "I just set the end_.";
}

} // namespace implementation
} // namespace ENDFtk
#endif  // ENDFTK_IMPLEMENTATION_FILESKELETON_SRC_FILESKELETON_HPP

