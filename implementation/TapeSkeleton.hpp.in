namespace ENDFtk{
namespace implementation{

template< typename BufferIterator >
class TapeSkeleton {
public:
  /* convenience typedefs */
  using MaterialSkeleton_t = MaterialSkeleton< BufferIterator >;
  
  /* nested classes */
  template< typename Parent >
  class MatchIterator_ : public Parent {
  public:
    template< typename... Args >
    MatchIterator_( Args&&... args ) :
      Parent( std::forward< Args >( args )... ){}
    
    MaterialSkeleton_t&
    operator*(){ return Parent::operator*().second; }
  };
  
  /* more convenience typedefs */
  using Iterator = typename std::vector< MaterialSkeleton_t >::iterator;
  using Multimap = std::unordered_multimap< int, MaterialSkeleton_t& >;
  using MatchIterator = MatchIterator_< typename Multimap::iterator >;
  
  /* fields */
  std::pair< BufferIterator, BufferIterator > bufferLimits;
  TapeIdentification tpid;
  std::vector< MaterialSkeleton_t > materialVector;
  std::unordered_multimap< int, MaterialSkeleton_t& > materialMap;

  /* ctor */
#include "ENDFtk/implementation/TapeSkeleton/src/createVector.hpp"
#include "ENDFtk/implementation/TapeSkeleton/src/createMap.hpp"
#include "ENDFtk/implementation/TapeSkeleton/src/ctor.hpp"

  /* methods */
#include "ENDFtk/implementation/TapeSkeleton/src/materialNumber.hpp"

  std::pair< MatchIterator, MatchIterator >
  MAT( int materialNo ){ return this->materialNumber( materialNo ); }

  bool
  hasMAT( int materialNo ){ return this->materialMap.count( materialNo ); }

  bool
  hasMaterialNumber( int materialNo ){ return this->hasMAT( materialNo ); }
  
  Iterator begin(){ return materialVector.begin(); }
  
  Iterator end(){ return materialVector.end(); }
  
  std::size_t size() const { return materialVector.size(); }

  BufferIterator bufferBegin() { return this->bufferLimits.first; }

  BufferIterator bufferEnd() { return this->bufferLimits.second ; }

  const TapeIdentification& TPID() const { return this->tpid; }
};

}
}
