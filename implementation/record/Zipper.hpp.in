#include <utility>

namespace ENDFtk {
namespace implementation {
namespace record {

struct Zipper {

  /* helper structs */
  template< typename Iterator >
  struct ReadingPack{
    Iterator& it;
    const Iterator& end;
    long& lineNumber;
    int MAT, MF, MT;

    ReadingPack( Iterator& it, const Iterator& end, long& lineNumber,
                 int MAT, int MF, int MT ) :
      it( it ),
      end( end ),
      lineNumber( lineNumber ),
      MAT( MAT ), MF( MF ), MT( MT ){}
  };
  
  template< typename... ENDFTypes  >
  struct Zipped {
    static constexpr std::size_t
    tupleWidth = helper::sum< ENDFTypes::width... >();
    
    static_assert( tupleWidth < 66, "too many entries on line" );

    static constexpr std::size_t entriesPerTuple = sizeof...( ENDFTypes );
    static constexpr std::size_t tuplesPerRecord = 66 / tupleWidth;

    static constexpr std::size_t
    entriesPerRecord = tuplesPerRecord * entriesPerTuple;
    
    static const std::size_t nPad = 66 % tupleWidth;

    /**
     * @brief 
     * This is dark magic to expand the parameter pack a number of times equal 
     * to the tuplesPerRecord class variable
     */
    template< std::size_t... indices >
    static decltype(auto)
    expand( std::index_sequence< indices... > ){
      return disco::Record
             < typename std::tuple_element
               < indices % entriesPerTuple,
                 std::tuple< typename ENDFTypes::Parser... > >::type... ,
               disco::ColumnPosition< nPad >, disco::RetainCarriage >();
    }

    using Format =
      decltype( expand( std::make_index_sequence< entriesPerRecord >() ) );

  };
    
  /* convenience aliases */
  template< std::size_t index >
  using shouldContinueToRecurse =
      std::conditional< ( index == 0 ), std::true_type, std::false_type >;

  /* helper methods */
#include "ENDFtk/implementation/record/Zipper/src/reserve.hpp"
#include "ENDFtk/implementation/record/Zipper/src/makeIteratorTuple.hpp"
#include "ENDFtk/implementation/record/Zipper/src/verifyTail.hpp"
#include "ENDFtk/implementation/record/Zipper/src/process.hpp"
#include "ENDFtk/implementation/record/Zipper/src/expandReferencePack.hpp"
#include "ENDFtk/implementation/record/Zipper/src/readLine.hpp"

//   /* methods */
//   template< typename... ENDFTypes, typename Iterator >
//   std::tuple< std::vector< typename ENDFTypes::Type >... >
//   unzip( uint64_t nEntries, Iterator& it, const Iterator& end, long& lineNumber,
//          int MAT, int MF, int MT ){
//     std::tuple< std::vector< typename ENDFTypes::Type >... > result;
//     reserve< ENDFTypes... >( nEntries, result, std::true_type() );
//     auto iterators = makeIteratorTuple< ENDFTypes::Type... >( result );
//     int remainingLines = nEntries / zipped< ENDFTypes... >::tuplesPerRecord;
//     while ( remainingLines-- ){
//       readLine< zipped< ENDFTypes... >::Format >
//       ( iterators, it, end, lineNumber, MAT, MF, MT );
//     }
//     return result;
//   }
    
};

}
}
}
