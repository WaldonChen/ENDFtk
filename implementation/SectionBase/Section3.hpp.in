#ifndef ENDFTK_IMPLEMENTATION_SECTIONBASE_SECTION_HPP
#define ENDFTK_IMPLEMENTATION_SECTIONBASE_SECTION_HPP

#include "ENDFtk/implementation/SectionBase.hpp"
#include "ENDFtk/implementation/UnivariateTabulation.hpp"

namespace ENDFtk{
namespace implementation{

/** @brief Section specialization for MF=3
 */
template<>
class Section<3>: protected SectionBase {
public:

  /**
   *
   * @details This verifies in the HEAD, TAB1, and SEND records:
   *  
   *  - `MAT` is correct, and
   *  - `MF` is 3
   *
   * This also verifies that the y-values in the TAB1 record are greater than
   * zero.
   *
   * @param \c head HeadRecord that beings the Section
   * @param \c begin Beginning @tparam Iterator from which the Section should be
   * created
   * @param \c begin Ending @tparam Iterator from which the Section should be
   * created
   * @param \c lineNumber
   * @param \c MAT, what Material number is expected. This is used for
   * verification.
   */
  template<typename Iterator>
  Section(HEAD& head, Iterator& begin, const Iterator& end, long& lineNumber,
          int MAT)
    try: SectionBase(head, MAT, 3),
         TAB1_(begin, end, lineNumber, head.MAT(), 3, head.MT() )
  { 

    auto ltzero = [](auto& y) { return y < 0.0; };
    auto found = std::find_if(TAB1_.yBegin(), TAB1_.yEnd(), ltzero);
    if( found != TAB1_.yEnd() ){
      LOG(ERROR) << "Found a negative cross section value: " << *found;
      throw std::exception();
    }

    readSEND(begin, end, lineNumber, MAT, 3 );

  } catch( std::exception& e ){
    LOG(INFO) << "Trouble constructing MF=3 Section.";
    throw e;
  }
    
  using SectionBase::MT;
  using SectionBase::ZA;
  using SectionBase::atomicWeightRatio;

  UnivariateTabulation TAB1_;

};

} // namespace implementation
} // namespace ENDFtk

#endif  // ENDFTK_IMPLEMENTATION_SECTIONBASE_SECTION_HPP

