#ifndef ENDFTK_IMPLEMENTATION_RECORDTAIL_HPP
#define ENDFTK_IMPLEMENTATION_RECORDTAIL_HPP

#include "ENDFtk/implementation.hpp"

/**@brief Small class to contain the MAT, MF, and MT of a Record---the tail of
 * the Record.
 */
class ENDFtk::implementation::RecordTail{
public:
  
  RecordTail( const int MAT, const int MF, const int MT );

  int MAT_;
  int MF_;
  int MT_;
};

namespace ENDFtk {
namespace implementation {

/*& @brief Class to verify that a passed in Material number is correct
 *
 * This throws an exception if the MAT numbers are not the same.
 */
template<typename tail>
class MAT: public tail{
public:
  template<typename... Args>
  MAT(int vMAT, Args... args)
    : tail(args...)
  {
    if( this->MAT_ != vMAT ){
      LOG(ERROR) << "The Material number: " << this->MAT_ << " is not correct.";
      LOG(INFO) << "The correct Material number is: " << vMAT;
      throw std::exception();
    }
  }
};

/*& @brief Class to verify that a passed in File number is correct
 *
 * This throws an exception if the MF numbers are not the same.
 */
template<typename tail>
class MF: public tail{
public:
  template<typename... Args>
  MF(int vMF, Args... args)
    : tail(args...)
  {
    if( this->MF_ != vMF ){
      LOG(ERROR) << "The File number: " << this->MF_ << " is not correct.";
      LOG(INFO) << "The correct File number is: " << vMF;
      throw std::exception();
    }
  }
};

/*& @brief Class to verify that a passed in Section number is correct
 *
 * This throws an exception if the MT numbers are not the same.
 */
template<typename tail>
class MT: public tail{
public:
  template<typename... Args>
  MT(int vMT, Args... args)
    : tail(args...)
  {
    if( this->MT_ != vMT ){
      LOG(ERROR) << "The Section number: " << this->MT_ << " is not correct.";
      LOG(INFO) << "The correct Section number is: " << vMT;
      throw std::exception();
    }
  }
};

template<template<typename> class... Ts>
struct TailVerifier;

template<>
struct TailVerifier<>{
  using type = RecordTail;
};

/** @brief Template magic
 */
template< template<typename> class T1, 
          template<typename> class... Ts>
struct TailVerifier<T1, Ts...>{
  using type = T1< typename TailVerifier<Ts...>::type >;
};

} // namespace implementation
} // namespace ENDFtk

#endif  // ENDFTK_IMPLEMENTATION_RECORDTAIL_HPP
